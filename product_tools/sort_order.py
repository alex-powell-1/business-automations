from pyodbc import Error

from product_tools import products
from product_tools.products import Product
from reporting.product_reports import create_top_items_report
from setup.date_presets import *
from setup.query_engine import QueryEngine

db = QueryEngine()


def sort_order_engine(log_file):
    """Sets sort order based on revenue data from prior year during the forecasted time period"""
    print(f"Sort Order: Starting at {datetime.now():%H:%M:%S}", file=log_file)
    # WITH SALES HISTORY DURING SALES WINDOW
    top_ecomm_items_with_stock = create_top_items_report(
        beginning_date=one_year_ago,
        ending_date=last_year_forecast,
        mode="sales",
        number_of_items=products.get_ecomm_items(),
        return_format=3)

    # ITEMS WITH STOCK AND SALES HISTORY -- STEP 1:
    # Set sort order for items with sales history during the selected date range
    # Sort order is generated by revenue.
    # Big Commerce prioritized the lowest value in category display. So, highest rank items get
    # the lowest value

    count = -1 * len(top_ecomm_items_with_stock)
    # iterators
    x = 0
    y = 1
    max_retries = 25
    print("Setting sort order for merged items: children only -- Starting", file=log_file)
    while x < len(top_ecomm_items_with_stock) and y <= max_retries:

        # check this out. Maybe problematic
        # took this out because of issues. 10093 not showing as high rank.
        # if ecomm_items_with_stock[x] in top_ecomm_items_with_stock:
        try:
            item = Product(top_ecomm_items_with_stock[x])
        except Error:
            # continues to the next iteration of the loop without increasing x for retry
            # y is increased so that if there are more than y failed requests, operation stops
            y += 1
            continue
        else:
            # Set sort order for child products
            if item.is_parent == 'N':
                try:
                    item.set_sort_order(target_sort_order=count, log_file=log_file)
                except Error:
                    y += 1
                    continue
                else:
                    count += 1
                    x += 1
            else:
                x += 1
        # else:
        #     x += 1

    if y == max_retries:
        print("Could not complete. Max Tries Reached.", file=log_file)
    else:
        print("Setting sort order for merged items: children only -- Completed!", file=log_file)

    # ITEMS WITH STOCK AND SALES HISTORY -- STEP 2:
    # Set sort order for parent items based on revenue of best-selling child product_tools

    print("Setting sort order for parents based on top child", file=log_file)

    x = 0
    y = 1
    max_tries = 25
    binding_ids = products.get_binding_ids()
    while x < len(binding_ids) and y <= max_tries:
        try:
            parent_product = Product(products.get_parent_product(binding_ids[x]))
            # Get sort order for highest performing child
            top_child_sort_order = Product(parent_product.get_top_child_product()).sort_order
            # Set the parent product to the sort order of the highest performing child
            parent_product.set_sort_order(target_sort_order=int(top_child_sort_order), log_file=log_file)
        except Error:
            y += 1
        else:
            x += 1
    if y == max_tries:
        print("Could not complete. Max Tries Reached.", file=log_file)
    else:
        print("Setting sort order for parents based on top child: Completed!", file=log_file)

    # ITEMS WITH STOCK AND SALES HISTORY -- STEP 3:
    # Clear out sort order values for child products

    query = f"""
    UPDATE IM_ITEM
    SET USR_PROF_ALPHA_27 = NULL
    WHERE USR_PROF_ALPHA_16 IS NOT NULL AND IS_ADM_TKT = 'N'
    """
    db.query_db(query, commit=True)

    print("Flushed all child sort orders (with sales history)", file=log_file)

    # PRODUCTS WITH STOCK AND NO SALES HISTORY

    # iterators
    x = 0
    y = 1
    max_retries = 25
    print("Setting sort order for items with no history -- Starting", file=log_file)
    no_history_items = products.get_items_with_no_sales_history()
    while x < len(no_history_items) and y <= max_retries:
        new_items = products.get_new_items(two_weeks_ago, today, 14.95)

        # STEP 1: SET OLD PRODUCTS WITH NO SALES HISTORY IN WINDOW TO SORT: -1

        if no_history_items[x] not in new_items:
            item = Product(no_history_items[x])
            try:
                item.set_sort_order(target_sort_order=-1, log_file=log_file)
            except Error:
                y += 1
            else:
                x += 1
        else:

            # STEP 2: SET NEW ITEMS WITH NO SALES HISTORY TO TOP RESULT PLUS 4
            # This will present new items in the 5 position

            count = (-1 * len(top_ecomm_items_with_stock)) + 4
            item = Product(no_history_items[x])
            try:
                item.set_sort_order(target_sort_order=count, log_file=log_file)
            except Error:
                y += 1
            else:
                x += 1
    if y == max_retries:
        print("Could not complete. Max Tries Reached.", file=log_file)
    else:
        print("Setting sort order for items with no history -- Completed!", file=log_file)

    # NO STOCK ITEMS (BUFFERED)

    zero_stock_ecomm_items = products.get_zero_stock_ecomm_products()

    x = 0
    y = 1
    max_retries = 25
    print("Setting sort order for items with no stock -- Starting.", file=log_file)
    while x < len(zero_stock_ecomm_items) and y < max_retries:
        item = Product(zero_stock_ecomm_items[x])

        # SINGLE ITEM WITH NO STOCK
        if item.binding_key is None:
            # Set sort order to 0
            try:
                item.set_sort_order(log_file=log_file)
            except Error:
                print(f"Singled Item Error {y}/{max_retries}", file=log_file)
                y += 1
            else:
                x += 1

        # MERGED PRODUCT WITH NO STOCK
        else:
            if item.is_parent == 'Y':
                combined_stock = products.get_merged_product_combined_stock(item.binding_key)
                if combined_stock == 0:
                    try:
                        item.set_sort_order(log_file=log_file)
                    except Error:
                        print(f"Merged Product Error {y}/{max_retries}", file=log_file)
                        y += 1
                    else:
                        x += 1
                else:
                    x += 1
            else:
                x += 1

    if y == max_retries:
        print("\nCould not complete. Max Tries Reached.", file=log_file)
    else:
        print("\nSetting sort order for items with no stock -- Completed!", file=log_file)

    print(f"Sort Order: Finished at {datetime.now():%H:%M:%S}", file=log_file)
    print("-----------------------", file=log_file)
